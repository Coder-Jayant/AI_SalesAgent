"""
Scheduled Action Plans Execution Module

Standalone execution of scheduled action plans, independent of autopilot.
"""

import os
import time
import logging
from typing import List, Dict, Any
from datetime import datetime
from zoneinfo import ZoneInfo
from pathlib import Path

logger = logging.getLogger(__name__)

# Execution lock to prevent concurrent runs
EXECUTION_LOCK_FILE = "action_plans_execution.lock"



def execute_scheduled_plans(hands_free: bool = False) -> List[Dict[str, Any]]:
    """
    Check and execute all action plans that are due for execution.
    
    This function is called by the independent action plan service.
    Uses execution locking to prevent concurrent runs.
    
    Args:
        hands_free: If True, allows actual email sending; if False, saves as drafts
    
    Returns:
        List of execution results with status, plan details, and any errors
    """
    # Acquire execution lock to prevent concurrent runs
    lock_path = Path(EXECUTION_LOCK_FILE)
    
    try:
        # Check if another execution is already running
        if lock_path.exists():
            age = time.time() - lock_path.stat().st_mtime
            if age < 300:  # 5 minutes
                logger.debug(f"[ScheduledPlans] Another execution in progress (lock age: {age:.0f}s), skipping")
                return []
            else:
                # Stale lock, remove it
                logger.warning(f"[ScheduledPlans] Removing stale lock (age: {age:.0f}s)")
                lock_path.unlink()
        
        # Create lock file
        lock_path.write_text(str(os.getpid()))
        logger.debug("[ScheduledPlans] Execution lock acquired")
        
    except Exception as e:
        logger.error(f"[ScheduledPlans] Failed to acquire lock: {e}")
        return []
    
    try:
        from action_plans import get_manager
        from scheduled_tasks import ScheduledTaskManager
        
        manager = get_manager()
        scheduler = ScheduledTaskManager()
        
        # Get all enabled plans
        plans = manager.list_plans(status_filter="enabled")
        
        if not plans:
            logger.debug("[ScheduledPlans] No enabled action plans")
            return []
        
        # Get current time in Indian timezone
        current_time = datetime.now(ZoneInfo("Asia/Kolkata"))
        logger.info(f"[ScheduledPlans] Checking {len(plans)} enabled plans at {current_time.strftime('%H:%M:%S')}")
        
        results = []
        
        for plan in plans:
            try:
                # Convert plan to dict for scheduler
                plan_dict = plan.to_dict()
                
                # Check if this plan should execute now
                should_run = scheduler.should_execute(plan_dict, current_time)
                
                if not should_run:
                    logger.debug(f"[ScheduledPlans] Plan '{plan.name}' not due (next: {plan.next_execution})")
                    continue
                
                logger.info(f"[ScheduledPlans] Executing plan: {plan.name} (ID: {plan.id})")
                
                # Execute the plan using ReAct agent
                execution_result = _execute_single_plan(plan, hands_free)
                
                # Update execution tracking based on result
                if execution_result["status"] == "success":
                    manager.update_plan(
                        plan.id,
                        last_executed=current_time.isoformat(),
                        execution_count=plan.execution_count + 1,
                        current_retries=0  # Reset retries on success
                    )
                    
                    # Calculate and update next execution time
                    next_exec = scheduler.get_next_execution_time(plan_dict)
                    if next_exec:
                        manager.update_plan(plan.id, next_execution=next_exec.isoformat())
                    
                    logger.info(f"[ScheduledPlans] SUCCESS: Plan '{plan.name}' executed successfully")
                    
                else:
                    # Handle failure with retry logic
                    current_retries = plan.current_retries + 1
                    
                    if current_retries < plan.max_retries:
                        # Schedule retry
                        from datetime import timedelta
                        retry_time = current_time + timedelta(minutes=plan.retry_delay_minutes)
                        
                        manager.update_plan(
                            plan.id,
                            failure_count=plan.failure_count + 1,
                            last_failure=current_time.isoformat(),
                            last_failure_reason=execution_result.get("error", "Unknown error"),
                            current_retries=current_retries,
                            next_execution=retry_time.isoformat()
                        )
                        
                        logger.warning(
                            f"[ScheduledPlans] FAILED: Plan '{plan.name}' failed (retry {current_retries}/{plan.max_retries}), "
                            f"retrying at {retry_time.strftime('%H:%M:%S')}"
                        )
                    else:
                        # Max retries reached, schedule next regular execution
                        next_exec = scheduler.get_next_execution_time(plan_dict)
                        
                        manager.update_plan(
                            plan.id,
                            failure_count=plan.failure_count + 1,
                            last_failure=current_time.isoformat(),
                            last_failure_reason=execution_result.get("error", "Unknown error"),
                            current_retries=0,  # Reset for next scheduled run
                            next_execution=next_exec.isoformat() if next_exec else None
                        )
                        
                        logger.error(
                            f"[ScheduledPlans] FAILED: Plan '{plan.name}' failed after {plan.max_retries} retries, "
                            f"next attempt: {next_exec.strftime('%Y-%m-%d %H:%M') if next_exec else 'never'}"
                        )
                
                # Record execution in history
                manager.add_execution_record(plan.id, execution_result)
                
                results.append({
                    "plan_id": plan.id,
                    "plan_name": plan.name,
                    **execution_result
                })
                
            except Exception as e:
                logger.exception(f"[ScheduledPlans] Error processing plan '{plan.name}': {e}")
                results.append({
                    "plan_id": plan.id,
                    "plan_name": plan.name,
                    "status": "error",
                    "error": str(e),
                    "timestamp": current_time.isoformat()
                })
        
        if results:
            logger.info(f"[ScheduledPlans] Completed: {len(results)} plans executed")
        
        return results
        
    except Exception as e:
        logger.exception(f"[ScheduledPlans] Fatal error in execute_scheduled_plans: {e}")
        return [{
            "status": "error",
            "error": f"Fatal error: {str(e)}",
            "timestamp": datetime.now(ZoneInfo("Asia/Kolkata")).isoformat()
        }]
    
    finally:
        # Always release the execution lock
        try:
            if lock_path.exists():
                lock_path.unlink()
                logger.debug("[ScheduledPlans] Execution lock released")
        except Exception as unlock_err:
            logger.error(f"[ScheduledPlans] Failed to release lock: {unlock_err}")



def _execute_single_plan(plan, hands_free: bool) -> Dict[str, Any]:
    """
    Execute a single action plan using the ReAct agent.
    
    Args:
        plan: ActionPlan object
        hands_free: Whether to allow actual sending
    
    Returns:
        Execution result dict
    """
    try:
        from autopilot import get_autopilot_react_agent
        from datetime import datetime
        from zoneinfo import ZoneInfo
        import os
        
        # Get current time for context
        current_time = datetime.now(ZoneInfo("Asia/Kolkata"))
        time_str = current_time.strftime('%A, %B %d, %Y at %I:%M %p %Z')
        
        # Get user identity from ENV for signatures
        user_name = os.getenv("AGENT_USER_NAME", "Sales Agent")
        user_email = os.getenv("EWS_EMAIL", "")
        
        # Build instruction for ReAct agent
        hands_free_mode = "ON - Can send emails directly" if hands_free else "OFF - Save all as drafts"
        
        instruction = f"""
SCHEDULED ACTION PLAN EXECUTION

**CURRENT TIME:** {time_str}
**YOUR IDENTITY:** {user_name} ({user_email})
**HANDS-FREE MODE:** {hands_free_mode}

Plan: {plan.name}
Task: {plan.task}
Hands-Free Mode: {hands_free_mode}

CRITICAL: You are EXECUTING an existing scheduled action plan. DO NOT create new action plans.

Execute the task described above using the appropriate tools.

Instructions:
1. Read and understand the task carefully
2. Execute the task directly using available tools (send_mail_tool, query_knowledge_base, etc.)
3. DO NOT call create_action_plan or update_action_plan - the plan already exists
4. If sending emails, use {'save_as_draft=False' if hands_free else 'save_as_draft=True'}
5. After completing the task, call end_task with a summary of what was done

Execute the task NOW. Do not create plans, just execute the task directly.
"""
        
        # Get ReAct agent and execute
        agent = get_autopilot_react_agent()
        
        logger.info(f"[ScheduledPlans] Running ReAct agent for plan '{plan.name}'...")
        final_answer = agent.run(
            user_input=instruction,
            max_iterations=20  # Allow more iterations for complex tasks
        )
        
        logger.info(f"[ScheduledPlans] Plan '{plan.name}' completed: {final_answer[:150]}...")
        
        return {
            "status": "success",
            "result": final_answer,
            "timestamp": datetime.now(ZoneInfo("Asia/Kolkata")).isoformat(),
            "hands_free": hands_free
        }
        
    except Exception as e:
        logger.exception(f"[ScheduledPlans] Execution failed for plan '{plan.name}': {e}")
        return {
            "status": "failed",
            "error": str(e),
            "timestamp": datetime.now(ZoneInfo("Asia/Kolkata")).isoformat()
        }
